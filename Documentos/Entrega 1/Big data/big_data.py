# -*- coding: utf-8 -*-
"""Big data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17I07FBbUigx53lujMff-thlNsn_5D89s
"""

# 1) COLETAR DADOS INICIAIS
import pandas as pd
from IPython.display import display

# ler os 4 CSVs (ajuste o caminho se estiver em outra pasta)
order    = pd.read_csv('/content/Order_semicolon.csv', sep=';')
customer = pd.read_csv('/content/Customer_semicolon.csv', sep=';')
cqueue   = pd.read_csv('/content/CampaignQueue_semicolon.csv', sep=';')
campaign = pd.read_csv('/content/Campaign_semicolon.csv', sep=';')

datasets = {
    'Order': order,
    'Customer': customer,
    'CampaignQueue': cqueue,
    'Campaign': campaign
}

for name, df in datasets.items():
    print(f'\n=== {name} ===')
    print('shape:', df.shape)
    display(df.head(3))
    print(df.dtypes)

# 2) EXPLORAR OS DADOS
import matplotlib.pyplot as plt
import numpy as np
from IPython.display import display

for name, df in datasets.items():
    print(f'\n=== {name} ===')

    num_cols = df.select_dtypes(include=np.number).columns.tolist()
    cat_cols = df.select_dtypes(exclude=np.number).columns.tolist()

    # estatísticas
    if num_cols:
        print('\nEstatísticas numéricas:')
        display(df[num_cols].describe().T)

    if cat_cols:
        print('\nEstatísticas categóricas:')
        display(df[cat_cols].describe().T)

    # histogramas (até 5 numéricas)
    for c in num_cols[:5]:
        plt.figure()
        df[c].dropna().hist(bins=30)
        plt.title(f'{name} - {c}')
        plt.xlabel(c); plt.ylabel('freq')
        plt.tight_layout(); plt.show()

    # barras top-10 (até 3 categóricas)
    for c in cat_cols[:3]:
        vc = df[c].astype(str).value_counts().head(10)
        plt.figure()
        vc.plot(kind='bar')
        plt.title(f'{name} - {c} (top 10)')
        plt.xlabel(c); plt.ylabel('contagem')
        plt.tight_layout(); plt.show()

    # correlação se houver >=2 numéricas
    if len(num_cols) >= 2:
        corr = df[num_cols].corr(numeric_only=True)
        plt.figure()
        plt.imshow(corr, interpolation='nearest')
        plt.title(f'Correlação - {name}')
        plt.colorbar()
        plt.xticks(range(len(corr.columns)), corr.columns, rotation=90, fontsize=8)
        plt.yticks(range(len(corr.index)), corr.index, fontsize=8)
        plt.tight_layout(); plt.show()

# 3) VERIFICAR A QUALIDADE DOS DADOS
import matplotlib.pyplot as plt
import numpy as np
from IPython.display import display

for name, df in datasets.items():
    print(f'\n=== {name} ===')

    # missing por coluna
    miss = (df.isna().mean()*100).sort_values(ascending=False)
    display(miss.to_frame('%_missing').head(20))
    plt.figure()
    miss.plot(kind='bar')
    plt.title(f'% missing por coluna - {name}')
    plt.ylabel('%'); plt.tight_layout(); plt.show()

    # duplicatas
    dup_mask = df.duplicated(keep=False)
    print('linhas duplicadas:', int(dup_mask.sum()))
    if dup_mask.any():
        display(df[dup_mask].head(10))

    # outliers (IQR) em colunas numéricas
    num_cols = df.select_dtypes(include=np.number).columns.tolist()
    for c in num_cols:
        s = pd.to_numeric(df[c], errors='coerce').dropna()
        if s.empty:
            continue
        q1, q3 = s.quantile([0.25, 0.75])
        iqr = q3 - q1
        low, high = q1 - 1.5*iqr, q3 + 1.5*iqr
        out_count = int(((s < low) | (s > high)).sum())
        print(f'outliers em {c}: {out_count} (limites {low:.3f} ~ {high:.3f})')